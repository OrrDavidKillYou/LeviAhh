<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Levi Painter</title>
  <style>
    :root { --bg: aquamarine; }
    html,body { height:100%; margin:0; }
    body {
      font-family: Arial, sans-serif;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:flex-start;
      gap:12px;
      background: var(--bg);
      padding:20px;
      box-sizing:border-box;
    }

    header { text-align:center; }
    .controls {
      width: 100%;
      max-width: 900px;
      background: rgba(255,255,255,0.9);
      padding: 12px;
      border-radius: 8px;
      box-shadow: 0 6px 18px rgba(0,0,0,0.12);
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
      justify-content:space-between;
    }

    .left, .right { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    #colorPicker { width:44px; height:34px; border:none; cursor:pointer; }
    #saveBtn { padding:8px 14px; border-radius:6px; background:#4CAF50; color:white; border:none; cursor:pointer; }
    #saveBtn:hover { background:#45a049; }
    .canvas-wrap { position:relative; width:100%; max-width:900px; border:2px solid #000; background:#fff; }
    canvas { display:block; width:100%; height:auto; user-select:none; -webkit-user-select:none; touch-action:none; }
    .label { font-size:13px; color:#222; }
    .brushControls button { padding:6px 10px; border-radius:6px; border:1px solid #ccc; background:white; cursor:pointer; }
    .brushControls button.active { background:#eee; border-color:#888; }
    .digga{
        color:crimson;
        font-size:20px;
        text-decoration:none;
    }
  </style>
    
</head>
<body>
    <a href="index.html"class="digga"title="to home">to home page</a>
  <header>
    <h1>levi painter</h1>
  </header>

  <div class="controls" role="toolbar" aria-label="painting controls">
    <div class="left">
      <input id="colorPicker" type="color" value="#000000" aria-label="color picker">
      <div class="brushControls">
        <button id="pencilBtn">Pencil</button>
        <button id="softBtn">Soft</button>
        <button id="pickBtn">Color Pick</button>
        <button id="eraserBtn">Eraser</button>
      </div>
      <label class="label">Brush Size
        <input id="brushSize" type="range" min="1" max="80" value="5">
      </label>
      <label class="label">Softness
        <input id="softness" type="range" min="0" max="1" step="0.01" value="0.5">
      </label>
    </div>

    <div class="right">
      <input id="uploadBtn" type="file" accept="image/*">
      <button id="saveBtn">Save Drawing</button>
    </div>
  </div>

  <div class="canvas-wrap" id="canvasWrap" style="max-width:900px;">
    <!-- background canvas (for uploaded image) -->
    <canvas id="bgCanvas" width="800" height="600" style="position:absolute; left:0; top:0; z-index:0;"></canvas>
    <!-- drawing canvas (for strokes) -->
    <canvas id="drawCanvas" width="800" height="600" style="position:relative; z-index:1;"></canvas>
  </div>

<script>
(() => {
  // DOM
  const colorPicker = document.getElementById('colorPicker');
  const uploadBtn = document.getElementById('uploadBtn');
  const saveBtn = document.getElementById('saveBtn');
  const brushSizeInput = document.getElementById('brushSize');
  const softnessInput = document.getElementById('softness');
  const pBtn = document.getElementById('pencilBtn');
  const sBtn = document.getElementById('softBtn');
  const pickBtn = document.getElementById('pickBtn');
  const eraserBtn = document.getElementById('eraserBtn');

  const bgCanvas = document.getElementById('bgCanvas');
  const drawCanvas = document.getElementById('drawCanvas');
  const bgCtx = bgCanvas.getContext('2d');
  const ctx = drawCanvas.getContext('2d');

  const wrap = document.getElementById('canvasWrap');

  // State
  let currentBrush = 'pencil'; // pencil, soft, colorPick, eraser
  let currentColor = colorPicker.value || '#000000';
  let brushSize = Number(brushSizeInput.value) || 5;
  let softness = Number(softnessInput.value) || 0.5;
  let painting = false;
  let lastPos = {x:0,y:0};
  let backgroundImage = null;

  // High-DPI scaling function
  function fitCanvasesToElement() {
    // canvas CSS width = element width; set physical size accordingly for crisp lines
    const rect = wrap.getBoundingClientRect();
    const cssWidth = rect.width;
    // maintain aspect ratio from base (800x600)
    const targetHeight = Math.round(cssWidth * 600 / 800);
    wrap.style.height = targetHeight + 'px';

    const dpr = window.devicePixelRatio || 1;
    // set physical size for both canvases
    [bgCanvas, drawCanvas].forEach(c => {
      c.width = Math.round(cssWidth * dpr);
      c.height = Math.round(targetHeight * dpr);
      c.style.width = cssWidth + 'px';
      c.style.height = targetHeight + 'px';
      const cctx = c.getContext('2d');
      cctx.setTransform(dpr, 0, 0, dpr, 0, 0); // normalize coords to CSS pixels
    });

    // if there is a background image, redraw it scaled
    if (backgroundImage) {
      bgCtx.clearRect(0,0,bgCanvas.width,bgCanvas.height);
      // drawImage will be transformed by setTransform already (we used dpr scaling)
      bgCtx.drawImage(backgroundImage, 0, 0, cssWidth, targetHeight);
    }
  }

  // Initialize sizing
  window.addEventListener('resize', fitCanvasesToElement);
  // call once
  fitCanvasesToElement();

  // Tools UI
  function setActiveButton(name) {
    [pBtn,sBtn,pickBtn,eraserBtn].forEach(b => b.classList.remove('active'));
    if (name === 'pencil') pBtn.classList.add('active');
    if (name === 'soft') sBtn.classList.add('active');
    if (name === 'colorPick') pickBtn.classList.add('active');
    if (name === 'eraser') eraserBtn.classList.add('active');
  }
  setActiveButton('pencil');

  pBtn.addEventListener('click', ()=>{ currentBrush='pencil'; setActiveButton('pencil'); });
  sBtn.addEventListener('click', ()=>{ currentBrush='soft'; setActiveButton('soft'); });
  pickBtn.addEventListener('click', ()=>{ currentBrush='colorPick'; setActiveButton('colorPick'); });
  eraserBtn.addEventListener('click', ()=>{ currentBrush='eraser'; setActiveButton('eraser'); });

  colorPicker.addEventListener('input', (e)=>{ currentColor = e.target.value; });

  brushSizeInput.addEventListener('input', (e)=>{ brushSize = Number(e.target.value); });
  softnessInput.addEventListener('input', (e)=>{ softness = Number(e.target.value); });

  // pointer helpers
  function getPointerPos(e, canvasElement) {
    // Use bounding rect to convert clientX/clientY to canvas CSS pixels
    const rect = canvasElement.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    return { x, y };
  }

  // Drawing behaviour: proper beginPath on down and lineTo on move
  function pointerDown(e) {
    // If color pick mode: pick pixel immediately
    if (currentBrush === 'colorPick') {
      pickColor(e);
      return;
    }

    // start drawing
    painting = true;
    const pos = getPointerPos(e, drawCanvas);
    lastPos = pos;
    ctx.lineWidth = brushSize;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    if (currentBrush === 'eraser') {
      ctx.globalCompositeOperation = 'destination-out';
      ctx.globalAlpha = 1;
      ctx.strokeStyle = 'rgba(0,0,0,1)';
    } else {
      ctx.globalCompositeOperation = 'source-over';
      ctx.globalAlpha = (currentBrush === 'soft') ? softness : 1;
      ctx.strokeStyle = currentColor;
    }

    ctx.beginPath();
    ctx.moveTo(pos.x, pos.y);
    // prevent default to avoid scrolling on touch
    e.preventDefault();
  }

  function pointerMove(e) {
    if (!painting) return;
    const pos = getPointerPos(e, drawCanvas);
    ctx.lineTo(pos.x, pos.y);
    ctx.stroke();
    // prepare for next segment
    ctx.beginPath();
    ctx.moveTo(pos.x, pos.y);
    lastPos = pos;
    e.preventDefault();
  }

  function pointerUp(e) {
    if (!painting) return;
    painting = false;
    // ensure path closed
    ctx.beginPath();
    ctx.globalCompositeOperation = 'source-over';
    ctx.globalAlpha = 1;
  }

  // Use pointer events for mouse/touch unified handling
  drawCanvas.addEventListener('pointerdown', pointerDown);
  window.addEventListener('pointermove', pointerMove);
  window.addEventListener('pointerup', pointerUp);
  // prevent touch gestures from selecting or scrolling while interacting with canvas
  drawCanvas.addEventListener('touchstart', (e)=>e.preventDefault(), {passive:false});

  // Upload background image
  uploadBtn.addEventListener('change', (ev) => {
    const file = ev.target.files && ev.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function(loadEv) {
      const img = new Image();
      img.onload = function() {
        backgroundImage = img;
        // redraw background scaled to CSS size
        fitCanvasesToElement();
      };
      img.src = loadEv.target.result;
    };
    reader.readAsDataURL(file);
  });

  // Pick color from composed image (bg + drawing)
  function pickColor(e) {
    // Create offscreen temp canvas sized to CSS pixels
    const rect = wrap.getBoundingClientRect();
    const cssW = rect.width;
    const cssH = rect.height;

    const temp = document.createElement('canvas');
    temp.width = cssW;
    temp.height = cssH;
    const tctx = temp.getContext('2d');

    // draw background (if exists)
    if (backgroundImage) {
      tctx.drawImage(backgroundImage, 0, 0, cssW, cssH);
    } else {
      // white background fallback
      tctx.fillStyle = '#ffffff';
      tctx.fillRect(0,0,cssW,cssH);
    }

    // draw the current strokes (drawCanvas has been transformed for DPR, but CSS pixels content is visible,
    // so draw the drawCanvas DOM image on temp at CSS size)
    tctx.drawImage(drawCanvas, 0, 0, cssW, cssH);

    // get pointer pos relative to composed (use event client coords)
    const pos = getPointerPos(e, wrap);
    const x = Math.floor(pos.x), y = Math.floor(pos.y);

    // clamp
    if (x < 0 || y < 0 || x >= temp.width || y >= temp.height) return;

    const data = tctx.getImageData(x, y, 1, 1).data;
    const hex = rgbToHex(data[0], data[1], data[2]);
    currentColor = hex;
    colorPicker.value = hex;
  }

  function rgbToHex(r,g,b){
    return "#" + [r,g,b].map(v => {
      const h = v.toString(16);
      return h.length===1 ? "0"+h : h;
    }).join('');
  }

  // Save: combine bg + draw into final image and trigger download
  saveBtn.addEventListener('click', () => {
    const rect = wrap.getBoundingClientRect();
    const cssW = Math.round(rect.width);
    const cssH = Math.round(rect.height);

    const temp = document.createElement('canvas');
    temp.width = cssW;
    temp.height = cssH;
    const tctx = temp.getContext('2d');

    if (backgroundImage) tctx.drawImage(backgroundImage, 0, 0, cssW, cssH);
    else { tctx.fillStyle = '#ffffff'; tctx.fillRect(0,0,cssW,cssH); }

    tctx.drawImage(drawCanvas, 0, 0, cssW, cssH);

    const url = temp.toDataURL('image/png');
    const a = document.createElement('a');
    a.href = url;
    a.download = 'drawing.png';
    a.click();
  });

  // initial canvas clearing style
  ctx.lineWidth = brushSize;
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';

  // call resize handler once more to ensure background is drawn if uploaded earlier
  fitCanvasesToElement();

  // small guard: if you navigate to the page and pointer capture oddities occur, reset painting
  window.addEventListener('blur', ()=>{ painting=false; ctx.beginPath(); });

})();
</script>
</body>
</html>
